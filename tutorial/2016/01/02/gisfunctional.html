<!DOCTYPE html>
<html lang="">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="ie=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <base href="">
    <title>Tutorial: Big GIS Data in R & Functional Programming - Nathan Lane - nathanlane.github.io</title>
    <meta name="author" content="Dr. Nathan Lane">
    <meta name="description" content="The personal webpage of Assistant Professor/Lecturer, Nathaniel Lane.">
    <link rel="stylesheet" href="/main.css">
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Karla:300,400,700">
</head>
<body>

<header class="block block-header-1">

  <div class="block-header-1--logo">
  <a href="http://nathanlane.info">Nathanlane.info</a>
  </div>

  <div class="block-header-1--nav">
    <ul>
      
      <li class="nav-item "><a href="">Main</a></li>
      
      <li class="nav-item "><a href="http://nathanlane.info/blog">Blog</a></li>
      
      <li class="nav-item "><a href="https://www.dropbox.com/s/2xgg325wwayo9s9/NathanLane_IIES_20172018.pdf?dl=0">CV</a></li>
      
    </ul>
  </div>

</header>

<section class="post--content">
	<section class="block block-one-column-1">
	  <div class="container">
	    <div class="columns">
	      <div class="column">

			  <h1>Tutorial: Big GIS Data in R & Functional Programming</h1>
			  <p></p>

			  <a href="/2016/01/02/gisfunctional.html">
<img src="/assets/thermalmap.jpg" width="600px">
</a><br>
<p>
<small>
Caption: "Thermal Map of North America. Delineating the Isothermal Zodiac, the Isothermal Axis of Identity, and its expansions up and down the 'Plateau' " From William Gilpinâ€™s "Mission of the North American People (1873)." Via <a href="http://makingmaps.net/2014/09/30/gilpins-map-of-the-isothermal-zodiac-and-axis-of-intensity-round-the-world-calcareous-plain-maritime-selvage-etc-etc-maps-1873/">the "Making Maps: DIY Cartography" blog.</a>
</small>
</p>

<h3>The Question</h3>
<p>How do I take over 100 NetCDF files, each containing thousands of layers of hourly raster data, and translate into dataset?</p>

<p>I'll flesh out the problem more,</p>

<ul>
<li><p><strong>NetCDF files.</strong> We have over 100 NetCDF datasets: <i> 1850weather.nc, 1851weather.nc , 1851weather , ... , 1971weather, ... etc.</i>.</p>
<li><p><strong>Raster layers.</strong> Each NetCDF is a stack of hourly raster layers: 1850weather.nc: <i> layer.hour1 , layer.hour2 , ... , layer.hour2000, ... etc</i>.</p>
<li><p><strong>Shapefiles.</strong> We also have a shapefile countaining country boundaries.</p>
<li><p><strong>Our goal.</strong> Extract a giant panel dataset, containing average hourly weather data for each country.</p>
</ul>

<p>In other words, we need a way to cycle through each NetCDF file and for every layer within a file, retrieve the average raster stats corresponding to each country in our shapefile. This adds up. </p>

<p>This problem is interesting because normal approaches to processing piles of raster data (using nested loops) takes forever. A more "functional" approach to the problem can be amazingly more efficient.</p>

<p>In this post I consider the ways in which we can tackle this problem (Part I.) and then motive a solution (Part 2.) for comfortably extracting statistics from gigs of GIS weather data.</p>

<h3>Part 1. - A comparison of Two Approaches.</h3>

<p>Consider two approaches to our problem, a conventional loop-based approach and an optimized approach.</p>

<p><strong>Conventional Dead Ends with Loops.</strong></p>

<p>
Most of us would attack the problem using nexted loops. The first loop reads and prepares the NetCDF file; a second deals with the raster layers within each file.
</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="m">1</span><span class="o">:</span><span class="n">number_of_netcdffiles</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

   </span><span class="c1"># Load file[i]</span><span class="w">
   </span><span class="c1"># Do preliminary stuff to file[i]</span><span class="w">

	</span><span class="k">for</span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="m">1</span><span class="o">:</span><span class="n">number_of_rasterlayers</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

     </span><span class="c1"># Extract geographic statistics from layer[l]</span><span class="w">
     </span><span class="c1"># Add statistics from layer[l] to a data set</span><span class="w">

	</span><span class="p">}</span><span class="w">

	 </span><span class="c1"># Save giant file for each NetCDF file</span><span class="w">

</span><span class="p">}</span></code></pre></figure>

<p>We're tempted to iterate over the raster layers ( <code>layer[l]</code> ) and use standard R GIS libraries to, say, extract everage values from the rasters over a country boundary shapefile (e.g. hourly weather readings over the borders of Finland). Above all, we're tempted to "harvest" the geographic statistics, taking the values we extract and collating them in a giant file.</p>

<p>Straight up, this is a bad idea.</p>

<p>Loops can be abysmal for these tasks. When iterating through objects with a <code>for()</code> loop, we're actually calling many tiny functions ... <i>over and over again</i>. Not only is the <code>for()</code> a function, but so is the ":", and so are the brackets "[ ]".</p>

<p>To make matters worse, when we manipulate a vector or data.frame with a for-loop, we're also making many internal copies of our objects. Unbeknownst to us, mundane data transormations can quickly fill out memory with repeated copies.</p>

<p>Moreover, embedded in our first attempt is the agony loop-based "data-harvesting." Unless we're carefull, using a loop to incrementally "grow" a dataset will bring your computer to its knees.</p>

<p><strong>Consider an Alternative Approach.</strong></p>

<p>Instead of loops, the following template - and specifically the full program in Part 2 - considers a solution more suited to R.</p>

<p>By combining functional style with the use of the <code>raster()</code> library, we eliminate the need for nested loops and boil the problem down to a streamlined "apply+function" structure.</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">generate_statistics_from_netcdf</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="w"> </span><span class="n">input_netcdffile</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
	</span><span class="c1"># Turn input_netcdffile into a "raster brick" ...</span><span class="w">
	</span><span class="c1"># Get statistics from "raster brick" ...</span><span class="w">
	</span><span class="c1"># Save statistics for input_netcdffile ...</span><span class="w">
</span><span class="p">}</span><span class="w">
</span><span class="n">lapply</span><span class="p">(</span><span class="w"> </span><span class="n">list_of_netcdffiles</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">generate_statistics_from_netcdffile</span><span class="p">)</span></code></pre></figure>

<p>Instead of using a for-loop to iterate over NetCDF weather files, we take a list of files <code>list_of_netcdffiles</code> and "apply" a big function, <code>generate_statistics_from_netcdf</code>.</p>

<p>We eliminate the entire inner loop with the help of <code>RasterBrick</code> manipulations. That is, instead of looping over the individual raster layers within a NetCDF file, we transform the NetCDF into a <code>RasterBrick</code> object and manipulate the collection of layers as a single object.</p>

Appealing to <code>RasterBrick</code> instead of cycling through individual layers feels a lot of like the practice of <emph>"vectorization"</emph>, where instead of iteraring over individual members of a vector one-by-one, we work directly with the vector. Stylistically, this is a common line of attack for writing more efficient code.</p>

<h3>Part 2. The Program.</h3>

<p>Let's expand the alternative template above into a full program.</p>

<p>The first part of the program defines our functions: the main <code> generate_datatable_from_rasterbricks</code> function and a set of small sub-functions used within it.</p>

<p>The <code>generate_datatable_from_rasterbricks</code> functon eats a raw NetCDF file, and using a a team of smaller functions, reads it as a RasterBrick, aligns it with our country shapefile, extracts the country-level weather statistcs, then saves the output file.</p>

<p>The second part contains the core code. Here we define a list of NetCDF raster files (<code>raster_file_list</code>) and the country shapefile (<code>countryshape</code>) used in our calculations. An *apply function feeds NetCDF files through the <code>generate_datatable_from_rasterbricks</code> function. </p>

<p>Instead of using <code>lapply</code> I use <code>mclapply</code>: the latter is a multiprocessor version of list-apply provided by the <code>parallel()</code> package. Conveniently, <code>mclapply</code> utilizes the power of out multi-core processor (if we have one).</p>

<p>The third part of the program takes our saved files and assembles them into a giant file via the amazingly useful functions provifed by the <code>data.table()</code>package. With <code>lapply()</code>, our list of .csv files is opened with the speedy <code>fread()</code> function. A list big list of opened .csv files is then fed through <code>rbindlist()</code>, which combines them into a single massive data.table.</p>


<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="c1"># ---- X. Header.</span><span class="w">

</span><span class="c1"># The libraries we use.</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">rgdal</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">raster</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">ncdf4</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">RNetCDF</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">parallel</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">magrittr</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">data.table</span><span class="p">)</span><span class="w">

</span><span class="c1"># Detect cores automatically, I usually free one up.</span><span class="w">
</span><span class="n">cores</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">detectCores</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="m">1</span><span class="w">


</span><span class="c1"># Define your file paths here.</span><span class="w">
</span><span class="n">weatherraster_path</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="s2">"/path/to/weatherrasterfiles"</span><span class="w">
</span><span class="n">countryshape_path</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="s2">"/path/to/countryshapefile"</span><span class="w">
</span><span class="n">output_path</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="s2">"/path/to/outputfiles"</span><span class="w">

</span><span class="c1"># ---- 1. Define Functions.</span><span class="w">

</span><span class="c1"># -- 1.A. Define Small Subfunctions.</span><span class="w">

</span><span class="c1"># Small function 1) Reads filename &amp; explicitly opens it as a NetCDF file.</span><span class="w">
</span><span class="n">open_netcdf_as_rasterbrick</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="w"> </span><span class="n">ncdf_filename_input</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

  </span><span class="n">ncdf_filename_input</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w">
  </span><span class="n">file.path</span><span class="p">(</span><span class="w"> </span><span class="n">weatherraster_path</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">.</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w">
  </span><span class="n">nc_open</span><span class="p">(</span><span class="w"> </span><span class="n">.</span><span class="w"> </span><span class="p">)</span><span class="w">  </span><span class="o">%&gt;%</span><span class="w">  </span><span class="c1"># Open path as NetCDF file.</span><span class="w">
  </span><span class="n">ncvar_get</span><span class="p">(</span><span class="w"> </span><span class="n">.</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w">  </span><span class="c1"># Get NetCDF file.</span><span class="w">


  </span><span class="c1"># Transform NetCDF into raster brick.</span><span class="w">

  </span><span class="c1"># NOTE: Your dimensions and CRS will differ,</span><span class="w">
  </span><span class="c1"># so these should be replaced.</span><span class="w">

  </span><span class="n">brick</span><span class="p">(</span><span class="w"> </span><span class="n">.</span><span class="w"> </span><span class="p">,</span><span class="n">ymn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">-0</span><span class="p">,</span><span class="w"> </span><span class="n">ymx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">360</span><span class="p">,</span><span class="w"> </span><span class="n">xmn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">-90</span><span class="p">,</span><span class="w"> </span><span class="n">xmx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">90</span><span class="p">,</span><span class="w">
             </span><span class="n">crs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"the string for your CRS"</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w">
  </span><span class="nf">return</span><span class="p">(</span><span class="w"> </span><span class="n">.</span><span class="w"> </span><span class="p">)</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="c1"># Small function 2) Transforms the raster brick to our country shapefile.</span><span class="w">
</span><span class="n">match_rainbrick_to_countryshape</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="w"> </span><span class="n">brick_input</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

  </span><span class="c1"># NOTE: Depending on your setting and the nature of the shapefile</span><span class="w">
  </span><span class="c1"># and NetCDF raster files you're using, you may have to do many more</span><span class="w">
  </span><span class="c1"># manipulations to make sure the raster layers align with the shapefile.</span><span class="w">

  </span><span class="n">brick_input</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w">
  </span><span class="c1"># Reproject raster brick to the shapefile's coordinate system.</span><span class="w">
  </span><span class="n">projectRaster</span><span class="p">(</span><span class="w"> </span><span class="n">.</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">crs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">proj4string</span><span class="p">(</span><span class="w"> </span><span class="n">countryshape</span><span class="w"> </span><span class="p">),</span><span class="w">
                   </span><span class="n">method</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"ngb"</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w">

  </span><span class="c1"># Crop to match the size of my country shapefile.</span><span class="w">
  </span><span class="n">raster</span><span class="o">::</span><span class="n">crop</span><span class="p">(</span><span class="w"> </span><span class="n">.</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">extent</span><span class="p">(</span><span class="w"> </span><span class="n">country_shapefile</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w">
  </span><span class="nf">return</span><span class="p">(</span><span class="w"> </span><span class="n">.</span><span class="w"> </span><span class="p">)</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="c1"># Small function 3) Extract data from a raster brick.</span><span class="w">
</span><span class="n">generate_data_from_rasterandshape</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="w"> </span><span class="n">brick_input</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

	</span><span class="n">brick_input</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w">
	</span><span class="c1"># Take means according to the countryshape.</span><span class="w">
	</span><span class="c1"># Make sure df = TRUE , so that output is a dataframe.</span><span class="w">
    </span><span class="n">raster</span><span class="o">::</span><span class="n">extract</span><span class="p">(</span><span class="w"> </span><span class="n">.</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">countryshape</span><span class="w"> </span><span class="p">,</span><span class="w">
    				</span><span class="n">f</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">,</span><span class="w"> </span><span class="n">fun</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mean</span><span class="p">,</span><span class="w"> </span><span class="n">na.rm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">TRUE</span><span class="w">  </span><span class="p">)</span><span class="w">
    </span><span class="nf">return</span><span class="p">(</span><span class="w"> </span><span class="n">.</span><span class="w"> </span><span class="p">)</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="c1"># Small function 4) Grab 4-digit year from input filename.</span><span class="w">
</span><span class="n">grab_year_from_inputfile</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="w"> </span><span class="n">ncdf_filename_input</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

  </span><span class="n">ncdf_filename_input</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w">
  </span><span class="n">regexpr</span><span class="p">(</span><span class="s2">"[0-9]+"</span><span class="p">,</span><span class="w"> </span><span class="n">.</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w">  </span><span class="c1"># Match 4-digit year.</span><span class="w">
  </span><span class="n">regmatches</span><span class="p">(</span><span class="w"> </span><span class="n">ncdf_filename_input</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">.</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w">  </span><span class="c1"># Get matched REGEX from input string.</span><span class="w">
  </span><span class="nf">return</span><span class="p">(</span><span class="w"> </span><span class="n">.</span><span class="w"> </span><span class="p">)</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="c1"># --- 1.B. Define "BIG" Function That Extracts Dataset From a NetCDF File.</span><span class="w">

</span><span class="n">generate_datatable_from_rasterbricks</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="w"> </span><span class="n">ncdf_filename_input</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

	</span><span class="c1"># Note: the only argument is a NetCDF filename.</span><span class="w">

	</span><span class="c1"># Start with file argument and process with the sub-functions above.</span><span class="w">
	</span><span class="n">ncdf_filename_input</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w">

	</span><span class="n">open_netcdf_as_rasterbrick</span><span class="p">(</span><span class="w"> </span><span class="n">.</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w">
	</span><span class="n">match_rainbrick_to_countryshape</span><span class="p">(</span><span class="w"> </span><span class="n">.</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w">
	</span><span class="n">generate_data_from_rasterandshape</span><span class="p">(</span><span class="w"> </span><span class="n">.</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">country_means_dataframe</span><span class="w">


	</span><span class="c1"># Go back to the file input name, create automatic names, and save.</span><span class="w">
	</span><span class="n">ncdf_filename_input</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w">

	</span><span class="n">grab_year_from_inputfile</span><span class="p">(</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w">
	</span><span class="n">write.csv</span><span class="p">(</span><span class="w"> </span><span class="n">country_means_dataframe</span><span class="w"> </span><span class="p">,</span><span class="w">
				</span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">file.path</span><span class="p">(</span><span class="w"> </span><span class="n">.</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">output_path</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="c1"># ---- 2. Main Code: Setup Environment to Run Big Function.</span><span class="w">

</span><span class="c1"># Start with your name of the country shapefile we're referencing.</span><span class="w">
</span><span class="s2">"country_shapefile_name.shp"</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w">
</span><span class="n">file.path</span><span class="p">(</span><span class="w"> </span><span class="n">countryshape_path</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w">
</span><span class="n">readODG</span><span class="p">(</span><span class="w"> </span><span class="n">den</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">.</span><span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">layer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"countries"</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">countryshape</span><span class="w">


</span><span class="c1"># Generate list of NetCDF files automatically from our directory.</span><span class="w">
</span><span class="c1"># Match all files ending in ".nc"</span><span class="w">
</span><span class="n">raster_file_list</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">list.files</span><span class="p">(</span><span class="w"> </span><span class="n">path</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">weatherraster_path</span><span class="w"> </span><span class="p">,</span><span class="w">
</span><span class="n">pattern</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">".nc"</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">all.files</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">FALSE</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">full.names</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">FALSE</span><span class="w"> </span><span class="p">)</span><span class="w">

</span><span class="c1"># Run our big function on the list of NetCDF files.</span><span class="w">
</span><span class="n">mclapply</span><span class="p">(</span><span class="w"> </span><span class="n">raster_file_list</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">generate_datatable_from_rasterbricks</span><span class="w"> </span><span class="p">)</span><span class="w">

</span><span class="c1"># ---- 3. Assemble .CSV Files using Data.Table and Lapply.</span><span class="w">

</span><span class="c1"># Fetch all files ending in .CSV in out output path.</span><span class="w">
</span><span class="n">csv_file_list</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">list.files</span><span class="p">(</span><span class="w"> </span><span class="n">path</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">output_path</span><span class="w"> </span><span class="p">,</span><span class="w">
                             </span><span class="n">pattern</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">".csv"</span><span class="p">,</span><span class="w">
                             </span><span class="n">all.files</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">FALSE</span><span class="p">,</span><span class="w">
                             </span><span class="n">full.names</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">TRUE</span><span class="p">,</span><span class="w">
                             </span><span class="n">recursive</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">FALSE</span><span class="w"> </span><span class="p">)</span><span class="w">

</span><span class="c1"># Take the list of saved files &amp; "fast read" them into R.</span><span class="w">
</span><span class="n">lapply</span><span class="p">(</span><span class="w"> </span><span class="n">csv_file_list</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">fread</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">sep</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">","</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w">

</span><span class="c1"># Transform the list of read files into a data.table:</span><span class="w">
</span><span class="n">rbindlist</span><span class="p">(</span><span class="w"> </span><span class="n">.</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">big_datatable</span><span class="w">


</span><span class="c1"># Note: Before reassembling the data, or after, you may want</span><span class="w">
</span><span class="c1"># to manipulate the data so that it is in a more usable format.</span><span class="w">

</span><span class="c1"># Note: You may want to setkeys() for data.table here.</span><span class="w">

</span><span class="c1"># Save the big file.</span><span class="w">
</span><span class="n">write.csv</span><span class="p">(</span><span class="w"> </span><span class="n">big_datatable</span><span class="p">,</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">file.path</span><span class="p">(</span><span class="w"> </span><span class="n">output_path</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="s2">"big_file_name.csv"</span><span class="p">)</span><span class="w"> </span><span class="p">)</span></code></pre></figure>


<h4>One thing to try.</h4>

<p><b>Compiling functions with R's byte-compiler</b></p>

<p>Writing our own functions also allows us to easily use R's <code>compiler()</code> on chunks of our code. The <code>cmpfun()</code> function allows us to generate byte-compiled versions of our own functions, </p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">c.myfunction</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">compiler</span><span class="o">::</span><span class="n">cmpfun</span><span class="p">(</span><span class="n">myfunction</span><span class="p">)</span></code></pre></figure>

<p>Sometimes byte-compiled function can give our programs another performance boost, often with minimal upfront costs, and can yield surprising gains in big data projects without having to turn to Rcpp/C++.</p>


			  <br>
			   <p class="post--date">02 Jan 2016</p>

	      </div>        
	    </div>
	  </div>
	</section>
</section>

<footer class="block block-footer-1">
  <div class="container">
    <p><a href="mailto:nathaniel.lane@gmail.com" title=""><strong>nathaniel.lane@monash.edu</strong></a> <span class="box"> â€¢ </span>Nathan Lane, 2014-2018 <span class="box"> â€¢ None of this garbage reflects my institution.</span></p>
  </div>
</footer>

  </body>
</html>